@name RLC Titus V3.0 Beta
@inputs Isolate Pod:entity EmBrake UsingRearSeat HEP_Up HEP_Down [Trucks FrontPlugIn RearPlugIn]:array Sand BatteryKnifeSwitch Primer Stop Genfield 
@inputs Fuelpump Eng_Run Control Fuelcutoff BrakeCutout Handbrake

# Outputs & cool stuff.
@outputs On Reverser Notch RealNotch Brake Dynamics DynaNotch MPH KPH V Clag ConstantClag LocoBrakePressure Emergency LB16M_Notch AB26L LB26L AB24RL_Notch
@outputs [FrontPlugOut RearPlugOut]:array CarCount WheelSlip Sanding RLCPT:entity Unlocked HEP_Mode Load BrakeInfo:array CurrentFuel TankFull TankLow BailOff
@outputs Voltage Current IncreaseDynamics DecreaseDynamics

# Notches and Engine Sounds
@persist [Idles Behavior]:array [Transition Startup Shutdown]:string Notch TargetNotch SQ On NQ TQ [UpDelays DownDelays]:array StartupClagStart StartupClagDuration
@persist [Lever_ReverserF Lever_ReverserN Lever_ReverserB Lever_Throttle]:string RevQ 

# Brakes
@persist [DynoOn DynoOff Lever_16M Lever_26L]:string DynaQ E:entity Starting Dynamics DynamicsEnable DNQ AirBrakeType LocoBrakePressure LB16M_Notch
@persist BailOff AB24RL_Notch ABQ [WheelSound BrakeScreech]:string WQ BQ EMQ BPQ CarCount Threshold_Hard Locked LBQ MaxLocoBrakeForce MaxTrainBrakeForce BrakeMul
@persist [AirBrakeApply AirBrakeRelease Lever_LocoBrake LocoBrakeRelease EmergencyBrakeSound]:string THQ IHQ HBQ Lever_HandBrake:string AirComStart CompressorSpeed
@persist [CompressorOn CompressorOff]:string ER Compressing MaxER AB26L LB26L LB26L_ClickQ BlendedBraking BlendQ InfiniteAir MainRes EqualRes BrakeLine BrakeCyl Switching
@persist LocoAirBrakeType EmergencyBrakeWheels:string

# Controls
@persist [Controls Routing]:table Alternate:string Alternate2:string Trig2 OldNotch DPM DPM_Delay DPM_Pitch DPMH:entity DPMS:string HEP HEP_Lock HEPQ

# Engine
@persist Horsepower TE_Starting TECON W:entity TMGearing:string Gearing:string GR T_N TransitionMode Current
@persist WheelSlipProb ETC [SanderOn SanderOff WheelSlipSound1 WheelSlipSound2]:string SandQ Sanding WSQ WSC

#Misc
@persist MU_OffsetPitch CarCount_Init O:entity ControlPrintOrder:array FuelSaver LowIdle:string LowIdling Mode3Q SaverQ HasTM UnitType HasEG CurrentFuel UseMul UseRate
@persist TankMax ReFRate A1 Primed EqualRes2 GRrelayAlarm TMVent TmfuseBlow PrimeSound:string EngineMute Selector PrimeTime HandBrakeType

@trigger Isolate ReFuel BatteryKnifeSwitch Primer 
@model models/cheeze/beta/white_button.mdl
if(first()|dupefinished()){
    #[
    Beta v3.81 
    
        Welcome to Magnum's RLC Platinum (RLC Pt for short) propulsion system modified by Titus, renamed RLC Titus! (This is so you don't overwrite normal PT)
        Please NOTE: This RLC is an Edit of Mags RLC Pt, I did not make this up in my head. This is simply an edited one with more detailed bits and bobs.
        In NO way SHAPE or FORM am I saying this is my Idea, This was only made for my OWN use.
        Copyright Notes:
              You are free to: Share and Edit/Remix.  Under the following conditions: Attribution to Magnum and Titus & Dont claim as your own work.
                        You are NOT free to: Share as your own work, Copy the code and redistribute edited version without permission.
                                             (CC) Some Rights Reserved, US Copyright Act of 1976.
                                    
        Credits:
        Magnum, Made RLC itself, had the idea for the base.
        Titus, hi. im in the name
        Groot, Helped me with detail for GE engines and was a Beta Tester.
        BPG, Helped with some of the code and ideas.
        SNW, Keeped on giving me support to continue with this E2.
        IceGT, "im not a rocker"
        Other Misc Friends, For ideas and keeping me on my feet from going crazy (I think I have, by giving this out lolwut)
        
        Thank you to everyone who has helped me with this and keeping me going, pushing the limits. You are very much kind hearted individuals. Big thanks.
        "Detail has no limits" - Titus 2018
        
        New Things:
        1. More I/O for e2s
        2. Updated Braking System (PSIs, Sounds, Better control, Etc)
        3. Improved Physics System
        4. Player-Based Speed Calculations
        5. Ground relay and warning systems so you dont blow out your TM Motors (NOW REMOVED, DUE TO HIGH OPS)
        6. Primer (Prime-Start)
        7. Isolation (Start-Run)
        8. Autobrake Cut-out (For MU)
        9. Control Stand switches (Gen, Ctrl, Fuel, EngRun) 
        10. Selector
        11. Automatic Tractive Effort Calculation based on Weight and Factor of Adhesion
        12. Battery
        13. Updated sounds, Already done for you...
        14. Made it possible to have the Locobrake and autobrake not as the same mode. (16M,26L)
        15. Made it take long to compress the air in a full consist, Please just wait for it, dont be a rocker....
        16. Possible to mute all engine sounds (Notching, Startups, Etc)
        17. Made wheelslip not as common, as its not irl.
        18. Added back Gearing
        19. Locomotive Brake Bail Off (Working, Press slash)
        20. Made it possible to notch up and make the air compressor go faster.
        21. Made the EQ Res and BrakePipe go up with the air compressor when starting.
        22. Now has 24RL, 26L brake settings.
        23. I added and later removed the Fuel System as it was not really something irl you need todo every time you start up the loco, and it was laggy lolz.
        24. Updated the Amp (Load) system to make it more realistic as you speed up.
        25. Updated the Traction and Motor systems, making it smoother and whatnot.
        26. Fully Configurable Controls
        27. Remote Control Support
        28. New Slug/Snail Modes
        29. Manual/Automatic Transition with Selector Lever Support
        30. Electronic Traction Control
        31. Brake squeel changes when in Em brake.
               
        
        Sidenote: This RLC is higher in OPS then RLC Pt. Due to the added detail, I plan to bring this down as much as I can to keep servers running happy. (OPS around 500-600)
        And don't say this E2 is lagging the server as its most likely not, I have made sure that the OPS that it has is not "bad Ops, ie, A broken code thats looping and not doing
        anything.
        
        Installation is almost the same as RLC RLC, except:
            *You need to wire Trucks[ARRAY] to an Adv. Ent marker that is linked to the trucks of the locomotive.
            *Pod[ENTITY] goes to the Pod Controller's "Entity" output (NOT to "Create Entity"!!!)
            *The Primer and Stop switch is Non-Toggled
        
    Full Setup Instructions:
        
        1- Configure Locomotive Config and Control Config for your Locomotive
        2- Place chip onto Locomotive body like you would attach a thruster. The Shiny bit needs to face backwards, towards the REAR of the locomotive. DO NOT PARENT IT!
        3- Wire Isolate to a toggled button. This is your Isolate switch.
        4- EmBrake can wire to a NON-Toggled button to apply the emergency brake with a button if needed.
        5- Wire Sand to a button on your control stand, this is your sander button.
        6- Wire BatteryKnifeSwitch to a Toggled button, this is the main battery breaker / Switch.
        7- Wire Primer to a NON-Toggled botton. This is the primer and engine start switch.
        8- Wire Stop to a NON-Toggled botton. This is the shutdown (Stop) button to turn off the locomotive.
        9- Wire the control switches (Genfield Fuelpump Eng_Run Control), to switches on your control stand.
        10- Fuelcutoff, is Fuelcutoff... (Wire to a NON-Toggled button if you have a spot for it on your loco)
        11- BrakeCutout is for cuting out the autobrakes in the locomotive.
        12- Wire Handbrake to a NON-Toggled button on the outside of the loco. (NOTE: This only works while the loco is on, you hold it till you hear it, aprox 5 seconds)
         
    
    Chat Commands:
    
        .engine - Toggles the Engine.
        .rev <N> - Changes the Reverser.
        .notch <N> - Changes the engine Notch.
        .brake <N> - Changes the Trainline Brake Pressure. If no argument, applies the Emergency Brake.
        .dynamics <N> - Engages/Disengages the Dynamic Brakes.
        .handbrake - Applies the Handbrake, which gives a rubber physprop to all cars in the consist.
        .controls - Prints the controls to your chat.
        .superice - "super ices" the entire train (Note: actually uses "friction_00").
        .count - Prints the total number of connected cars, assuming 3-prop cars.
        
    Miscellaneous Notes:
    
        The MU System is backwards compatible with RLC and RLC AB, but the RLC Titus unit /MUST/ be the master unit!
        
    MU Setup:
        1- On ALL the trailing units, Set/Turn on the Isolate (Set to Start. not Run)
        2- Cut-out autobrakes in trailing units
        3- Wire MU like you would with RLC. (You can still use Plugs, if your lazy)
        
        !!Read the OP Manual on the RLC to find out more!!
    ]#
    #-----------------
    #Locomotive Config
    #-----------------
    
    local LocomotiveType = "EMD SW7" #The Locomotive model designation, for naming purposes.
    local EngineType = "EMD 567C" #The Engine model, for naming purposes.
    
    Weight = 248000 #Locomotive Weight ON DRIVERS in lb; meaningless if there are no traction motors.
    
    Adhesion = 0.25 #Factor of Adhesion:
    #Older Road Locomotives are about 25%
    #Switchers and Road Locomotives with High-Adhesion trucks are about 30-32%
    #Modern AC Traction locomotives are about 45-50%
    
    Motors = 4 #Number of Traction Motors. Anything else is just absurd, really. Meaningless for Cabcars/Snails. (4 for 2 Axel bogies, 6 for 3 Axel Bogies.)
    TopSpeed = 65 #Top Speed, in Miles per Hour, that the locomotive is capable of reaching due to the gearing. If you don't know, put 65.
    
    UnitType = 0 #0 for Normal Locomotive (Has TM Motors + Engine)
                       #1 for Slug Unit (Has TM Motors, No Engine)
                       #2 for Snail Unit (Has No TM Motors, and has an Engine)
    
    
    EngineMute = 1 #1, To mute the engine sounds (Notching, Startups, Etc) 0, Not muted, just like normal
    
    AirComStart = 25000 #How long from startup untill the air compressor starts, this is in ms.) For Jazzlok Engine sounds: 25000, Grovestreet: 0 or more if you want.
    
    Horsepower = 1200 #Engine Horsepower
    
    DynamicsEnable = 1 #0 for No Dynamic Braking, Includes selector
                       #1 for Normal Dynamic Braking, Includes selector
                       #2 for "Notch 4" Dynamic Braking (ALCO style), Doesn't Include selector
                       #3 for Blended Dynamic Braking (Modern Passenger Locomotives), Doesn't Include selector
                    
    Selector = 1 #0 for No selector dynamic lever. 1 for Selector dynamic lever.
    
    ETC = 0 #Electronic Traction Control setting. 0 for no ETC (Hard), 1 for ETC (Easy), 2 to Disable Wheelslip entirely (Lazy).
    
    AirBrakeType = 0 #0 for 24RL Airbrakes (Newer, Harder), 1 for 26L Airbrakes (Easier)
    LocoAirBrakeType = 1 #0 for 16M Locomotive Airbrakes (Harder), 1 for 26L Locomotive Airbrakes (Easier).
    HandBrakeType = 0 #0 for Wheel Type Handbrake, 1 for Crank Type Handbrake
    
    #26L Airbrakes are more modern, and can provide up to 90psi of pressure. The Increase and Decrease keys will add/subtract pressure for as long as you hold them.
    #24RL Airbrakes are Newer. These where used on most EMD locomotives. Im not going to explain all the notches as there are too many. If you use this, you know what your
    #doing, and how to use them.
    
    Gearing = "62:15" #Traction motor Gear Ratio. 62:15 is the standard freight gearing. Larger 1st numbers trade tractive effort for speed.
    
    HEP = 0 #Set this to 1 if the locomotive is equipped for passenger service and uses the Prime Mover as HEP generators.
    DPM = 0 #if 1, will play an additional prime mover sound in addition to the main one
    BrakeMul = 775 #Don't Touch This
    
# Default Controls

#   ReverserF: W
#   ReverserB: S
#   IncreaseThrottle: D
#   DecreaseThrottle: A
#   IncreaseDynamics: Right Arrow
#   DecreaseDynamics: Left Arrow
#   IncreaseTrainBrake: Shift + W
#   DecreaseTrainBrake: Shift + S
#   IncreaseLocoBrake: Right Control
#   DecreaseLocoBrake: Right Alt
#   EmergencyBrake: Right Shift
#   HandBrake: H
#   Sander: Period
#   Bailoff: Slash 



# Selector
    
#   To use the selector, use the dynamic keys.
#   The Selector will act as the "Mode" key for your TM Motors.
#   When in "1" power will be applied to the TM Motors.
#   When in "OFF" no power will be applied to the TM Motors
#   When in "B" this stands for Braking, as in Dynamics. If you keep pressing "Right Arrow (Or what ever you have it set as)" Your notch will go up, This goes thru 2-8,
#   for Dynamic braking.
    
    #--------------
    #Control Config
    #--------------
    
    #You can actually change this, but be careful.
    #Wiremod key names do not always coincide with source key names!
    
    Alternate = "lalt" #When pressing this key, all controls with "!ALT" next to them will be triggered, and all the other will be ignored.
    Alternate2 = "lshift" #When pressing this key, all controls with "!ALT" next to them will be triggered, and all the other will be ignored.
    
    
    Controls["ReverserF",string]        = "W"
    Controls["ReverserB",string]        = "S"
    
    Controls["IncreaseThrottle",string] = "D"
    Controls["DecreaseThrottle",string] = "A"
    
    Controls["IncreaseDynamics",string] = "RIGHT"
    Controls["DecreaseDynamics",string] = "LEFT"
    
    Controls["IncreaseTrainBrake",string]    = "W !ALT"
    Controls["DecreaseTrainBrake",string]    = "S !ALT"
    
    Controls["IncreaseLocoBrake",string] = "rbracket"
    Controls["DecreaseLocoBrake",string] = "lbracket"
    
    Controls["EmergencyBrake",string] = "rshift"
    
    Controls["HandBrake",string] = "H"
    
    Controls["Sander",string] = "period"
    
    Controls["BailOff",string] = "slash"
    
    
    
    #Ignore this
    ControlPrintOrder = array("ReverserF","ReverserB","IncreaseThrottle","DecreaseThrottle","IncreaseDynamics","DecreaseDynamics","IncreaseTrainBrake","DecreaseTrainBrake","IncreaseLocoBrake","DecreaseLocoBrake","EmergencyBrake","HandBrake","Sander","BailOff")
    
    
    
    #-----------------
    #Sound/Clag Config
    #-----------------
    
    #You probably shouldn't touch anything below here unless you REALLY know what you're doing.
    
    #\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
    
    Startup = ""   #Startup and Shutdown
    Shutdown = ""
    
    StartupClagStart = 1     #Clag Config
    StartupClagDuration = 7
    
    Idles = array(                                  #Sounds used for each Notch
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
    )
    Transition = "gsgtrainsounds/emd567/transitions/" #The folder path for the transition sounds.
    
                    #1-2 2-3 3-4 4-5 5-6 6-7 7-8 
    UpDelays = array(100,100,200,400,400,500,500)
                      #8-7 7-6 6-5 5-4 4-3 3-2 2-1
    DownDelays = array(500,500,700,800,700,700,750)
                    #0-1 1-2 2-3 3-4 4-5 5-6 6-7 7-8
    Behavior = array(0,  0,  0,  0,  0,  0,  0,  0)
    #0: Normal A/B Notching
    #1: Full Sweep
    #2: Instant Transition
    #3: No Change
    
    #///////////////////////////////////
    
    LowIdle = "gsgtrainsounds/emd645tv20/idle_low.wav" #Don't touch these unless you know what you are doing!
    FuelSaver = 0, LowIdling = 0
    
    DynoOn = "gsgtrainsounds/misc/emd_late_dyn_loop.wav"    #Dynamic Brake Sounds
    DynoOff = "gsgtrainsounds/misc/emd_late_dyn_end.wav"
    
    Lever_ReverserF = ""      #Cab Lever Sounds
    Lever_ReverserN = ""
    Lever_ReverserB = ""
    
    Lever_Throttle = "" 
    
    Lever_16M = ""
    Lever_26L = ""
    Lever_24RL = ""
    
    PrimeSound = "_jazzlok/diesel_engines/emd_engines/engine_prime.wav"
    PrimeTime = 8000 #This is in ms.
    
    Lever_LocoBrake = "titus's_trainbuild_content_pack_1.1/propper/brakes/ind_half.wav"
    
    WheelSound = "moztrainsounds/steam/generic/track_jointed1.wav"     #Wheel Noises
    BrakeScreech = "_jazzlok/brakes/braking04.wav"             #Brake Screech
    
    AirBrakeApply = ""     #Sounds for Trainline Airbrakes
    AirBrakeRelease = ""   
    
    LocoBrakeRelease = "titus's_trainbuild_content_pack_1.1/propper/brakes/ind_half_dump.wav" #Locomotive brakes' apply sounds are very quiet so we just included a release.
    
    EmergencyBrakeSound = "_jazzlok/brakes/air_brake_quick_2.wav"  #The sound of the engineer shitting his pants
    EmergencyBrakeWheels = "_jazzlok/brakes/slippy.wav"
    
    CompressorOn = "titus's_trainbuild_content_pack_1.1/compressors/gd_wbo_compressor_ns5642_loop.wav"
    CompressorOff = "titus's_trainbuild_content_pack_1.1/compressors/gd_wbo_compressor_ns5642_end.wav"
    
    SanderOn = "_jazzlok/misc/sanding_on.wav"    #Not to be confused with Bernie Sanders
    SanderOff = ""
    
    WheelSlipSound1 = "_jazzlok/traction/wheel_grind_01.wav"  #Sounds for Wheelslip
    WheelSlipSound2 = "_jazzlok/traction/wheel_grind_02.wav"
    
    Threshold_Hard = 0.25 #Speed, in mph, below which the train brakes will hold the train.
    
    
    DPM_Delay = 200 #Delay in ms for the 2nd prime mover to get the message
    DPM_Pitch = 2 #Extra Pitch to give the 2nd Prime Mover
    
    
    #Sound Index Register (You don't need to know this)
    
    #0 - Engine Sounds
    #1 - Cab Levers
    #2 - Dynamic Brake Fans
    #3 - Wheel Sound
    #4 - Brake Screech
    #5 - Train Brake Hiss
    #6 - Sander
    #7 - Dual Prime Mover
    #8 - Air Compressor
    
    
    #----
    #Init
    #----
    
    if(BatteryKnifeSwitch < 1){
        Isolate = 0
        }
        
    #Controls Init
    
    foreach(K,V:string = Controls){
        if(V:find(" !ALT")){
            Routing[K,number] = 1
            local EXP = V:explode(" ")
            Controls[K,string] = EXP[1,string]
        }else{
            Routing[K,number] = 0
        }
    }
    
    #Sounds Init
    
    #DPM
    if(DPM){
        DPMH = holoCreate(0,entity():isWeldedTo():pos(),vec(1),ang(),vec(255),"cube")
        holoParent(0,entity())
        DPMH:propDraw(0)
        
    }
    
    function void lowidlestop(){
        stoptimer("lowidlestart")
        #print("                Stopping Timer")
        SaverQ = 0
    }
    
    #Tickrate-Adjusted Sound Duration
    function number sdr(Soundpath:string){
        local Tick = round(1/tickInterval())
        
        return floor(soundDuration(Soundpath)*100)*10/((Tick==33) ? 2 : 1)
    }
    
    function number startTransition(From,To){
        lowidlestop()
        
        if(To > From){
            Clag = 1
            
            local BType = Behavior[From+1,number]
            if(LowIdling){
                #LowIdling = 0
                LowIdling = 0
                local Snd = Transition + "up/0-1.wav"
                W:soundPlay(0,0,Snd)
                if(DPM & !HEP_Lock){
                    DPMS = Snd
                    timer("dpm",DPM_Delay)
                }
                timer("level",sdr(Snd))
                
                
                return From+1
            }elseif(BType==1){
                #Full Sweep
                #local Snd = Transition + "up/0-1.wav"
                local Nc = From:toString()
                local Nn = (From+1):toString()
                local Snd = Transition + "up/" + Nc + "-" + Nn + ".wav"
                if(!HEP_Lock){W:soundPlay(0,0,Snd)}
                local SDR = sdr(Snd)
                timer("level",SDR)
                timer("manclag",floor(SDR/20)*10)
                Mode3Q = 0
                #print("============Full")
                return From 
                
                if(DPM & !HEP_Lock){
                    DPMS = Snd
                    timer("dpm",DPM_Delay)
                }
            }elseif(BType==0){
                #Normal AB
                local Nc = From:toString()
                local Nn = (From+1):toString()
                local Snd = Transition + "up/" + Nc + "-" + Nn + "a.wav"
                if(!HEP_Lock){W:soundPlay(0,0,Snd)}
                timer("abu",sdr(Snd)-50)
                return From
                
                if(DPM & !HEP_Lock){
                    DPMS = Snd
                    timer("dpm",DPM_Delay)
                }
            }elseif(BType>=2){
                timer("level",500)
                if(BType==3){
                    Mode3Q = 1
                }
                return From+1
                
            
                
            }
        }elseif(To < From){
            Clag = 0
            local BType = Behavior[From,number]
            #print("                                " + BType)
            #Pod:printDriver(BType:toString())
            if(BType==1){
                #Full Sweep
                local Nc = From:toString()
                local Nn = (From-1):toString()
                local Snd = Transition + "down/" + Nc + "-" + Nn + ".wav"
                if(!HEP_Lock){W:soundPlay(0,0,Snd)}
                timer("level",sdr(Snd))
                Mode3Q = 0
                #print("============Full")
                return From-1
                
                if(DPM & !HEP_Lock){
                    DPMS = Snd
                    timer("dpm",DPM_Delay)
                }
            }elseif(BType==0){
                #Normal AB
                local Nc = From:toString()
                local Nn = (From-1):toString()
                local Snd = Transition + "down/" + Nc + "-" + Nn + "a.wav"
                if(!HEP_Lock){W:soundPlay(0,0,Snd)}
                timer("abd",sdr(Snd)-50)
                return From
                
                if(DPM & !HEP_Lock){
                    DPMS = Snd
                    timer("dpm",DPM_Delay)
                } 
            }elseif(BType>=2){
                timer("level",500)
                
                if(BType==3){
                    Mode3Q = 1
                }
                return From-1
                
            }
        }else{
            return From
        }
        
    }
    function number tq_evaluate(From,To){
        return    (From!=To)
    }
    function void entity:printProper(Message:string){
        if(This==O){
            print(Message)
        }else{
            Pod:printDriver(Message)
        }
    }
    
    #Locomotive Init
    Notch = 0
    RealNotch = 0
    Reverser = 0
    AB24RL_Notch = AirBrakeType ? 0 : 1
    AB24RL_Notch = -1
    
    function number entity:extraProps(Init){
        local Extra = Switching ? 0 : floor((E:getConstraints():count() - Init)/3)
        MaxTrainBrakeForce = BrakeMul*Extra/(70)
        return Extra
        
    }
    function void array:abRest(){
        
        foreach(K,V:entity = This){
            V:propPhysicalMaterial("phx_tire_normal")
        }
    }
    function void entity:abRelease(){
        local Ents = E:getConstraints()
        foreach(K,V:entity = Ents){
            V:propPhysicalMaterial("friction_00")
        }
    }
   
    
    
    #Misc Init 
    
    Starting = 0
    SQ = 0
    On = 0
    NQ = 0
    DNQ = 0
    TQ = 0
    Notch = 0
    RealNotch = 0
    DynaNotch = -1
    Clag = 0
    RevQ = 0
    DynaQ = 0
    BlendQ = 0
    RLCPT = E = entity()
    O = owner()
    ABQ = 0
    LBQ = 0
    WQ = 0
    BQ = 0
    Mode3Q = 0
    
    local GetGears = Gearing:explode(":")
    local GIn = GetGears[1,string]:toNumber()
    local GOut = GetGears[2,string]:toNumber()
    
    local GearRatio = GOut/GIn
    GR = GearRatio*62/15    
    
    MainRes = 0
    EqualRes = 0
    BrakeLine = 0
    BrakeCyl = 0
    
    #MaxER = AirBrakeType ? 90 : 70
    #AB26L = AirBrakeType ? 45 : 0
    #LB26L = 0
    #TrainBrakePressure = MaxER/2
    LocoBrakePressure = 0
    #ER = 0
    
    BrakeInfo = array(MainRes,EqualRes,BrakeLine,LocoBrakePressure,BrakeCyl)
    
    LB26L_ClickQ = 0
    BPQ = 0
    EMQ = 0
    Locked = 0
    Emergency = 0
    THQ = IHQ = 0
    HBQ = 0
    
    WheelSlipProb = 1/264
    SandQ = 0
    Sanding = 0
    WSQ = 0
    WSC = 0
    
    Trig2 = 0
    OldNotch = 0
    #HEP_Notch = 0
    HEP_Mode = 0
    HEPQ = 0
    
    Switching = 0
    
    TE_Starting = Weight*Adhesion
    
    FrontPlugOut = array()
    RearPlugOut = array()
    
    W = E:isWeldedTo()
    
#    ControlStandProp = entity()
    
    E:setSubMaterial(2,"debug/env_cubemap_model")
    
    CarCount_Init = E:getConstraints():count()
    
    MaxLocoBrakeForce = 300000/70
    MaxTrainBrakeForce = 0
    
    if(->Pod){
     soundPlay("ErrorSound",0,"buttons/button3.wav")   
    }else{
        printColor(vec(255,191,0),"[RLC TITUS] Error: Cannot find Pod Controller! Please reload E2 when the Pod Controller is wired.")
        soundPlay("ErrorSound",0,"buttons/button2.wav")
        exit()
    }
    
    runOnChat(1)
    
    setName("RLC Titus Beta 3.0! : "+EngineType+"\n"+LocomotiveType)
}
#=============================
#Startup & Shutdown, Misc Clks
#=============================

MU_Master =!Isolate

if(changed(Isolate)){
    E:soundPlay(1001,0,"titus's_trainbuild_content_pack_1.1/propper/misc/levers/button06.wav")
}
 
if(changed(Isolate & Primer & !On & !Genfield & Fuelpump & Control & Eng_Run& BatteryKnifeSwitch)&Isolate & Primer & !On & !Genfield & Fuelpump & Control & Eng_Run&BatteryKnifeSwitch){
    timer("Primer",PrimeTime)
    W:soundPlay(1000,0,PrimeSound)
    soundPitch(1000,100)
}
elseif(changed(Isolate&!Primer)&Isolate&!Primer){
    stoptimer("Pimer")    
    soundStop(1000,1)
    Primed=0
}
if(clk("Primer")&Primer){
    stoptimer("Pimer")    
    soundStop(1000,1)
    Primed=1   
}

if(changed(Fuelcutoff == 1)&Fuelcutoff==1){
    Stop = 1
}

if(((Primed==1|(Stop&On)) & !SQ &(BatteryKnifeSwitch&TankLow==0))|(On&TankLow)){
    
    SQ = 1
    Starting = !Starting

    if(Starting){
        
        local Snd = FuelSaver ? (LowIdling ? Startup:sub(1,Startup:length()-4) + "_low.wav" : Startup) : Startup
        W:soundPlay(0,0,Snd)
        timer("run",10*floor(soundDuration(Snd)*50) - 500)
        timer("startclag",StartupClagStart*1000)
        
        if(DPM){
            DPMS = Snd
            timer("dpm",sdr(Snd)-500)
        }
        
    }else{
        On = 0
        Primed=0
        local Snd = FuelSaver ? (LowIdling ? Shutdown:sub(1,Shutdown:length()-4) + "_low.wav" : Shutdown) : Shutdown
        W:soundPlay(0,0,Snd)
        stopAllTimers()
        timer("cool",10*floor(soundDuration(Snd)*50))
        if(DPM){
            DPMS = Snd
            timer("dpm",sdr(Snd))
        }
    }
}elseif(!Primed & SQ){
    SQ = 0
    
}#elseif(Primed & !SQ & !On){
#print("RLC Titus V3, Error. Please check that everything is Fueled up and all switches are on.")
#}


if(Starting & clk("run")){
    On = 1
    W:soundPlay(0,0,LowIdling ? LowIdle : Idles[1,string])
    RealNotch = 0
    Notch = 0
    timer("count",5000)
    CarCount = E:extraProps(CarCount_Init)
    if(DPM){
        #print("Run")
        DPMS = LowIdling ? LowIdle : Idles[1,string]
        timer("dpm",sdr(Startup))
    }
    #Compressing = 1
    #W:soundPlay(8,0,CompressorOn)
    #if(!MU_Master){TrainBrakePressure=0}
    
}
if(clk("cool")){
    soundStop(0)
    if(Compressing){
        W:soundPlay(8,2,CompressorOff)
        Compressing = 0
    }
    #ER = 0
        
}elseif(clk("startclag")){
    Clag = 1
    timer("endclag",StartupClagDuration*1000)
}elseif(clk("endclag")){
    Clag = 0
}elseif(clk("count")){
    CarCount = E:extraProps(CarCount_Init)
    
    if(MU_Master){
        MU_OffsetPitch = 0
    }else{
        local CF = (FrontPlugIn:count()>=5)
        local CR = (RearPlugIn:count()>=5)
        MU_OffsetPitch = (CF&CR) ? -2 : 2
    }
    if(!Compressing & (MainRes > 0)){MainRes += -1}
    timer("count",5000)
}elseif(clk("THQ")){
    THQ = 0
    soundStop(5)
}elseif(clk("IHQ")){
    IHQ = 0
    soundStop(5)
}elseif(clk("manclag")){
    RealNotch++
}elseif(clk("WheelSlipEnd")){
    WheelSlip = 0
    soundStop(7)
    WSQ = 1
    timer("WheelSlipStart",500)
}elseif(clk("WheelSlipStart")){
    WSQ = 0
}elseif(clk("mu_recheck")){

    if(DynamicsEnable){
        local MU_Dynamics = FrontPlugIn[4,number] + RearPlugIn[4,number]
        if(MU_Dynamics & !Dynamics){
            Dynamics = 1
        }elseif(!MU_Dynamics & Dynamics){
            Dynamics = 0 
        }
    }
    
    local NotchMU = 0.8*(FrontPlugIn[2,number] + RearPlugIn[2,number])
    
    if(!Dynamics & (Notch!=NotchMU)){
        Notch = NotchMU
        TQ = tq_evaluate(RealNotch,Notch)
        RealNotch = startTransition(RealNotch,Notch)
    }elseif(Dynamics & DynaNotch!=NotchMU){
        DynaNotch = NotchMU
        if(DynamicsEnable==1){
            Notch = DynaNotch>3 ? DynaNotch : 0
            if(!TQ){
                TQ = tq_evaluate(RealNotch,Notch)
                RealNotch = startTransition(RealNotch,Notch)
            }
        }
    }
}elseif(clk("dpm")){
    DPMH:soundPlay(7,0,DPMS)
    #print(DPMS)
    soundPitch(7,100+DPM_Pitch)
}elseif(clk("highidle")){
    #print("highidle")
    local Snd = Idles[1,string]
    W:soundPlay(0,0,Snd)
    if(DPM & !HEP_Lock){
        DPMS = Snd
        timer("dpm",DPM_Delay)
    }
}elseif(clk("lowidlestart")){
    #print("lowidlestart")
    
    LowIdling = 1
    local Snd = Transition + "down/1-0.wav"
    W:soundPlay(0,0,Snd)
    if(DPM & !HEP_Lock){
        DPMS = Snd
        timer("dpm",DPM_Delay)
    }
    timer("lowidle",sdr(Snd))
}elseif(clk("lowidle")){
    #print("lowidle")
    W:soundPlay(0,0,LowIdle)
    if(DPM & !HEP_Lock){
        DPMS = LowIdle
        timer("dpm",DPM_Delay)
    }
}

#==============
#Engine Running
#==============

if(On){
    interval(50)
    
    if(Trig2){
        Trig2 = 0
        Trig = 1
    }else{
        Trig = 0
    }
    
    #------------------
    #Control Resolution
    #------------------
    
    Driver = Pod:driver()
    
    if(Driver & MU_Master){
        
        local Shifting = Driver:keyPressed(Alternate)
        local Shifting = Driver:keyPressed(Alternate2)
        
        local RF = UsingRearSeat ? "ReverserB" : "ReverserF"
        local RB = UsingRearSeat ? "ReverserF" : "ReverserB"
        
        ReverserF = Driver:keyPressed(Controls[RF,string]) & (Routing[RF,number] ? Shifting : !Shifting)
        ReverserB = Driver:keyPressed(Controls[RB,string]) & (Routing[RB,number] ? Shifting : !Shifting)
        
        IncreaseThrottle = Driver:keyPressed(Controls["IncreaseThrottle",string]) & (Routing["IncreaseThrottle",number] ? Shifting : !Shifting)
        DecreaseThrottle = Driver:keyPressed(Controls["DecreaseThrottle",string]) & (Routing["DecreaseThrottle",number] ? Shifting : !Shifting)
        
        IncreaseTrainBrake = Driver:keyPressed(Controls["IncreaseTrainBrake",string]) & (Routing["IncreaseTrainBrake",number] ? Shifting : !Shifting)
        DecreaseTrainBrake = Driver:keyPressed(Controls["DecreaseTrainBrake",string]) & (Routing["DecreaseTrainBrake",number] ? Shifting : !Shifting)
        
        IncreaseLocoBrake = Driver:keyPressed(Controls["IncreaseLocoBrake",string]) & (Routing["IncreaseLocoBrake",number] ? Shifting : !Shifting)
        DecreaseLocoBrake = Driver:keyPressed(Controls["DecreaseLocoBrake",string]) & (Routing["DecreaseLocoBrake",number] ? Shifting : !Shifting)
        
        if(DynamicsEnable){
            IncreaseDynamics = Driver:keyPressed(Controls["IncreaseDynamics",string]) & (Routing["IncreaseDynamics",number] ? Shifting : !Shifting)
            DecreaseDynamics = Driver:keyPressed(Controls["DecreaseDynamics",string]) & (Routing["DecreaseDynamics",number] ? Shifting : !Shifting)
        }
        EmergencyBrake = Driver:keyPressed(Controls["EmergencyBrake",string]) & (Routing["EmergencyBrake",number] ? Shifting : !Shifting)
        
        HandBrake = Driver:keyPressed(Controls["HandBrake",string]) & (Routing["HandBrake",number] ? Shifting : !Shifting)
        Sander = Sand 
        BailOff = Driver:keyPressed(Controls["BailOff",string]) & (Routing["BailOff",number] ? Shifting : !Shifting)
        
    }elseif(!MU_Master){
        #------------
        #MU Receiving
        #------------
        
        if(FrontPlugIn[5,number] | RearPlugIn[5,number]){
            stoptimer("mu_recheck")
            timer("mu_recheck",1000)
            
            Reverser = -FrontPlugIn[1,number] + RearPlugIn[1,number]
            
            
            
            
            
            
            #print("Recv")
            
            
            
            if(DynamicsEnable){
                local MU_Dynamics = FrontPlugIn[4,number] + RearPlugIn[4,number]
                if(MU_Dynamics & !Dynamics){
                    Dynamics = 1
                }elseif(!MU_Dynamics & Dynamics){
                    Dynamics = 0 
                }
            }
            
            local ThrottleMU = FrontPlugIn[2,number] + RearPlugIn[2,number]
            Notch = Dynamics ? Notch : ThrottleMU*0.8
            DynaNotch = Dynamics ? ThrottleMU*0.8 : -1
            
            if(!Dynamics){
                TQ = tq_evaluate(RealNotch,Notch)
                RealNotch = startTransition(RealNotch,Notch)
            }
            
            Sanding = FrontPlugIn[6,number] + RearPlugIn[6,number]
            
        }
    }
    
    #-----------------
    #Engine Sound Code
    #-----------------
    
    #Notch Up By Control
    if(IncreaseThrottle & !NQ & (Notch<8) & !Dynamics & DynaNotch!=-1 & DynaNotch <4 & Genfield){
        NQ = 1
        Notch++
        if(!TQ){
            #TQ = RealNotch==0 ? 0 : 1
            
            
            TQ = tq_evaluate(RealNotch,Notch)
            RealNotch = startTransition(RealNotch,Notch)
            
            
            Pod:soundPlay(1,0.5,Lever_Throttle)           
        }
        Trig = 1
    }
    
    if(clk("abu")){
        #print("ab up")
        local Nc = RealNotch:toString()
        local Nn = (RealNotch+1):toString()
        local Snd = Transition + "up/" + Nc + "-" + Nn + "b.wav"
        RealNotch++
        if(!HEP_Lock){W:soundPlay(0,0,Snd)} 
        if((RealNotch < Notch) & (Behavior[RealNotch,number]==0)){
            timer("abu",UpDelays[RealNotch-1,number])
            #print(UpDelays[RealNotch-1,number])
        }else{
            timer("level",sdr(Snd)-50)
            Mode3Q = 0
        }
        
        if(DPM & !HEP_Lock){
            DPMS = Snd
            timer("dpm",DPM_Delay)
        }
    }
    
    #Notch Down By Control
    
    if(DecreaseThrottle & !NQ & (Notch>0) & !Dynamics & DynaNotch!=-1 & DynaNotch <4 & Genfield){
        NQ = 1
        Notch--
        if(!TQ){
            #TQ = RealNotch==1 ? 0 : 1
            
            TQ = tq_evaluate(RealNotch,Notch)
            RealNotch = startTransition(RealNotch,Notch)
            
            Pod:soundPlay(1,0.5,Lever_Throttle)
        }
        Trig = 1
    }
    if(!IncreaseThrottle & !DecreaseThrottle & NQ){
        NQ = 0
    }
    
    if(clk("abd")){
        #print("ab down")
        local Nc = RealNotch:toString()
        local Nn = (RealNotch-1):toString()
        local Snd = Transition + "down/" + Nc + "-" + Nn + "b.wav"
        #print(Snd)
        RealNotch--
        if(!HEP_Lock){W:soundPlay(0,0,Snd)}
        if((RealNotch > Notch) & (Behavior[RealNotch,number]==0)){
            timer("abd",DownDelays[8-RealNotch,number])
            #print(DownDelays[8-RealNotch,number])
        }else{
            timer("level",sdr(Snd)-50)
            Mode3Q = 0
            #print("descending to " + (RealNotch-1))
        }
        
        if(DPM & !HEP_Lock){
            DPMS = Snd
            timer("dpm",DPM_Delay)
        }
    }
    
    #Leveling Out
    if(clk("level")){
        #print("----------------------Leveling at N" + RealNotch + ", Mode3Q = " + Mode3Q)
        if(RealNotch == Notch){
            Clag = 0
            if(!HEP_Lock & !Mode3Q){
                W:soundPlay(0,0,Idles[RealNotch+1,string])
                
            }
            
            Mode3Q = 0
            soundPitch(0,100+MU_OffsetPitch)
            TQ = 0
            #print("levelout")
            if(DPM & !HEP_Lock){
                DPMS = Idles[RealNotch+1,string]
                timer("dpm",DPM_Delay)
            }
            if(HEPQ){
                HEPQ = 0
                HEP_Lock = (HEP_Mode>0)
                Notch = RealNotch = 0
            }
        }else{
            TQ = 1
            RealNotch = startTransition(RealNotch,Notch)
            
            #print("This is what is happening!")
            local BType = Behavior[RealNotch+1,number]
            #print("                            "+BType)
            if(BType>=2){
                W:soundPlay(0,0,Idles[RealNotch+1,string])
            }
            
        }
    }
    
    #Count Clagula V3
    #Clag = Notch > RealNotch
    
    #----------------------------------
    #Shit you have to be in Notch 0 for
    #----------------------------------
    if(RealNotch==0){
        
        #Reverser
        
        if(ReverserF & !RevQ & (Reverser<1) & (!Dynamics)){
            RevQ = 1
            Reverser++
            Pod:soundPlay(1,1,Reverser==1 ? Lever_ReverserF : Lever_ReverserN)
            Trig = 1
        }elseif(ReverserB & !RevQ & (Reverser>-1) & (!Dynamics)){
            RevQ = 1
            Reverser--
            Pod:soundPlay(1,1,Reverser==-1 ? Lever_ReverserB : Lever_ReverserN)
            Trig = 1
        }elseif(!ReverserF & !ReverserB & RevQ){
            RevQ = 0
        }
        
        #Fuel Saver
        if(FuelSaver){
            if((Reverser!=0) & LowIdling){
                LowIdling = 0
                local Snd = Transition + "up/0-1.wav"
                W:soundPlay(0,0,Snd)
                if(DPM & !HEP_Lock){
                    DPMS = Snd
                    timer("dpm",DPM_Delay)
                }
                timer("highidle",sdr(Snd))
                lowidlestop()
                
            }elseif((Reverser!=0) & !LowIdling & SaverQ){
                lowidlestop()
            
            
            }elseif((Reverser==0) & !LowIdling & !SaverQ){
                
                lowidlestop()
                SaverQ = 1
                timer("lowidlestart",30000)
                #print("                  Starting Timer")
            }
        }
        
        #HEP Switch
        
        if(HEP){
            if(Reverser==0 & !HEPQ){
                if(HEP_Up & (HEP_Mode<2)){
                    HEPQ = 1
                    HEP_Lock = 0
                    HEP_Mode++
                    Notch = HEP_Mode*4
                    TQ = tq_evaluate(Notch-4,Notch)
                    RealNotch = startTransition(Notch-4,Notch)
                    
                    
                }elseif(HEP_Down & (HEP_Mode>0)){
                    HEPQ = 1
                    HEP_Lock = 0
                    HEP_Mode--
                    Notch = HEP_Mode*4  
                    TQ = tq_evaluate(Notch+4,Notch)
                    RealNotch = startTransition(Notch+4,Notch)
                }
            }
        }
    }
    #--------------
    #Dynamic Brakes
    #--------------
        if(DynamicsEnable){
            if(Selector){
                if(IncreaseDynamics & !DNQ & (DynaNotch<12)){
                #print("blah")
                DNQ = 1
            
                local CanEngage = (DynaNotch==4) ? (RealNotch==0) : 1
                
                if((Reverser!=0) & CanEngage){   
                DynaNotch++
                Pod:soundPlay(1,1,Lever_Throttle)
                Trig = 1
            }
                if(DynamicsEnable==1 & DynaNotch > 4){
                    Notch = DynaNotch -4
                    if(!TQ){
                        TQ = tq_evaluate(RealNotch,Notch)
                        RealNotch = startTransition(RealNotch,Notch)
                    }
                    
                
                }
                
                Dynamics = DynaNotch > 4 ? DynaNotch : 0
            
                }elseif(DecreaseDynamics & !DNQ & (DynaNotch>-1)){
                DNQ = 1
            
                if(Reverser!=0){
                DynaNotch--
                Pod:soundPlay(1,1,Lever_Throttle)
                Trig = 1
                if(DynamicsEnable==1 & DynaNotch >3){
                    Notch = DynaNotch -4
                    if(!TQ){
                        TQ = tq_evaluate(RealNotch,Notch)
                        RealNotch = startTransition(RealNotch,Notch)
                    }
                }
                } 
            Dynamics = DynaNotch > 4
            }elseif(!IncreaseDynamics & !DecreaseDynamics & DNQ){
            DNQ = 0
            }
    }
    elseif(!Selector){
            if(DynamicsEnable){
            if(IncreaseDynamics & !DNQ & (DynaNotch<8)){
            #print("blah")
            DNQ = 1
            
            local CanEngage = (DynaNotch==-1) ? (RealNotch==0) : 1
            if((Reverser!=0) & CanEngage){
                DynaNotch++
                Pod:soundPlay(1,1,Lever_Throttle)
                Trig = 1
                if(DynamicsEnable==1){
                    Notch = DynaNotch
                    if(!TQ){
                        TQ = tq_evaluate(RealNotch,Notch)
                        RealNotch = startTransition(RealNotch,Notch)
                    }
                }
            }
            Dynamics = DynaNotch > -1
            
            }elseif(DecreaseDynamics & !DNQ & (DynaNotch>-1)){
            DNQ = 1
            
            if(Reverser!=0){
                DynaNotch--
                Pod:soundPlay(1,1,Lever_Throttle)
                Trig = 1
                if(DynamicsEnable==1){
                    Notch = DynaNotch > -1 ? DynaNotch : 0
                    if(!TQ){
                        TQ = tq_evaluate(RealNotch,Notch)
                        RealNotch = startTransition(RealNotch,Notch)
                    }
                }
            }
            Dynamics = DynaNotch > -1
        }elseif(!IncreaseDynamics & !DecreaseDynamics & DNQ){
            DNQ = 0
        }
        #Dynamics = DynaNotch > 0
        
        if(Dynamics & !DynaQ){
            DynaQ = 1
            W:soundPlay(2,0,DynoOn)
            if(DynamicsEnable==2){
                Notch = 4
                TQ = tq_evaluate(RealNotch,Notch)
                RealNotch = startTransition(RealNotch,Notch)
            }
        }elseif(!Dynamics & DynaQ){
            DynaQ = 0
            W:soundPlay(2,7,DynoOff)
            if(DynamicsEnable==2){
                Notch = 0
                TQ = tq_evaluate(RealNotch,Notch)
                RealNotch = startTransition(RealNotch,Notch)
            }
        }
        
    }
}
        #Dynamics = DynaNotch > 0
        
        if(Dynamics & !DynaQ){
            DynaQ = 1
            W:soundPlay(2,0,DynoOn)
            if(DynamicsEnable==2){
                Notch = 4
                TQ = tq_evaluate(RealNotch,Notch)
                RealNotch = startTransition(RealNotch,Notch)
            }
        }elseif(!Dynamics & DynaQ){
            DynaQ = 0
            W:soundPlay(2,7,DynoOff)
            if(DynamicsEnable==2){
                Notch = 0
                TQ = tq_evaluate(RealNotch,Notch)
                RealNotch = startTransition(RealNotch,Notch)
            }
        }
        
    }
    #Blended Braking
    if(DynamicsEnable==3){
        
        local Blend = ((90-BrakeLine)>=10) & (MPH>5)
        #print(MU_Dynamics)
        if(Blend & !BlendQ & (Reverser!=0)){
            BlendQ = 1
            Dynamics = 1
            HEP_Lock = 1
            DynaNotch = 0
            #Pod:soundPlay(1,1,Lever_Throttle)
            #W:soundPlay(2,0,DynoOn)
            #print("Blend on")
            
        }elseif((!Blend | (Reverser==0)) & BlendQ){
            BlendQ = 0
            Dynamics = 0
            DynaNotch = -1
            HEP_Lock = (HEP_Mode>0)
            #W:soundPlay(2,7,DynoOff) 
            #print("Blend Off")
        }
        
    }
    
    if(DynamicsEnable == 0){
    DynaNotch = -1 
    }
    elseif(DynamicsEnable == 1){
    DynaNotch = DynaNotch
    }
    elseif(DynamicsEnable == 2){
    DynaNotch = -1  
    }
    elseif(DynamicsEnable == 3){
    DynaNotch = -1    
    }
      
    #-----------------------
    #Velocity Info Gathering
    #-----------------------
    V = -E:velL():z()
    MPH = abs(toUnit("mph",V))
    KPH = abs(toUnit("km/h",V))
    
    Moving = MPH>Threshold_Hard
    #Wheel Sound
    if(Moving){
        if(!WQ){
            WQ = 1
            W:soundPlay(3,0,WheelSound)
            Pod:soundPlay("CabRattle",0,"_jazzlok/misc/cab_rattle.wav")
        }
        soundPitch(3,MPH*5)
        soundVolume(3,MPH*0.4)
        soundVolume("Flange",MPH*0.01)
        soundVolume("CabRattle",MPH/3)
    }elseif(!Moving & WQ){
        WQ = 0
        soundStop(3,5)
        soundStop("CabRattle",5)
    }
    
    #----------------------------
    #Instantaneous TE Calculation
    #----------------------------
    
    if(Reverser!=0 & !Dynamics & !HEPQ & (HEP_Mode != 1)){
        local Throttle = min(RealNotch,Notch)
        local TEG = TE_Starting*GR
        local HPG = Horsepower/GR
        TE = 2*Reverser*TEG*Throttle*exp(-100*MPH/HPG)
        
        
        
    }else{
        TE = 0
    }
    
    
    #--------------------------
    #Dynamic Brake Calculations
    #--------------------------
    
    if(Dynamics & DynamicsEnable){
        local Rightway = sign(V)==sign(Reverser)
        local Throttle = DynaNotch
        DynaForce = Reverser*(MPH*MPH)*Throttle*Horsepower*Rightway/16
        
    }else{
        DynaForce = 0
    }
    #==========================
    #Train Brake And Loco Brake
    #==========================
    
    local MU_Connected = (FrontPlugIn:count() + RearPlugIn:count()) > 5
    if(!MU_Master & MU_Connected){
        MainRes = FrontPlugIn[9,number] + RearPlugIn[9,number]
        #EqualRes = 90
        AB24RL_Notch = -1
    }
    local NumCompressors = FrontPlugIn[8,number] + RearPlugIn[8,number] + 1
    
    
    
    #----------
    #Compresors
    #----------
    if(On & MainRes<90){
        timer("AirComGovStart", AirComStart)
    }
    
    if(clk("AirComGovStart")& MainRes<90 & !Compressing){
        Compressing = 1
        W:soundPlay(8,0,CompressorOn)
        stoptimer("AirComGovStart")
    }elseif((MainRes>140) & Compressing){
        Compressing = 0
        W:soundPlay(8,4,CompressorOff)
        stoptimer("AirComGovStart")
    }
    if(Compressing){MainRes += CompressorSpeed*NumCompressors}
    
    
    #--------------------
    #Equalizing Reservoir
    #--------------------
    
    if(AirBrakeType){
        #26L Trainline
        if(IncreaseTrainBrake & (EqualRes>0) & !ABQ){
            ABQ = 1
            Pod:soundPlay(1,1,Lever_26L)
        }elseif(DecreaseTrainBrake & (EqualRes<90) & !ABQ){
            ABQ = 1
            Pod:soundPlay(1,1,Lever_26L)
        }elseif(!DecreaseTrainBrake & !IncreaseTrainBrake & ABQ){
            ABQ = 0
        }
        AB24RL_Notch = IncreaseTrainBrake - DecreaseTrainBrake
    }else{
        #24RL Trainline
        if(IncreaseTrainBrake & (AB24RL_Notch<3) & !ABQ){
            ABQ = 1
            Pod:soundPlay(1,1,Lever_24RL)
            AB24RL_Notch++
        }elseif(DecreaseTrainBrake & (AB24RL_Notch>-1) & !ABQ){
            ABQ = 1
            Pod:soundPlay(1,1,Lever_24RL)
            AB24RL_Notch--
        }elseif(!DecreaseTrainBrake & !IncreaseTrainBrake & ABQ){
           ABQ = 0
    }
    } 

    #ER Hiss
    if((AB24RL_Notch==1) & (EqualRes>0) & !THQ){
        THQ = 1
        W:soundPlay(5,4,AirBrakeApply)
        soundPitch(5,115)
        timer("THQ",6000)
    }

    #ER Indexing   
    if(AirBrakeType == 0 & AB24RL_Notch==1 & MainRes>EqualRes){
        if(EqualRes>0){
             EqualRes -= 0.6
        }
    }
    elseif(AirBrakeType == 0 & AB24RL_Notch==-1 & MainRes-4>EqualRes){
        if(EqualRes<90){
             EqualRes += 0.6
        }
    }
    
    if(changed(Notch == 0)&Notch == 0){
        CompressorSpeed = 0.1
    }
    elseif(changed(Notch == 1)&Notch == 1){
        CompressorSpeed = 0.15
    }
    elseif(changed(Notch>1)&Notch>1){
        CompressorSpeed = 0.2
    }
    elseif(changed(Notch>4)&Notch>4){
        CompressorSpeed = 0.3
    }
    
    #----------
    #Brake Line
    #----------
    if(changed(CarCount) & (($CarCount)>0)){
        BrakeLine *= (CarCount - $CarCount)/CarCount
    }
    if(BrakeLine > EqualRes){
        #Apply
        BrakeLine -= 0.5/(CarCount/16 + 1)
    if(BrakeLine > EqualRes & LocoBrakePressure<65){
        LocoBrakePressure += 0.3/(CarCount/16 + 1)
    }
        
        
    }elseif(BrakeLine < EqualRes & MainRes-7>BrakeLine){
        #Release
        if(MainRes>40){
            MainRes -= 0.125*(CarCount/4 + 1)/NumCompressors
            BrakeLine += 0.5/(CarCount/16 + 1)
    }
    }
    if(abs(EqualRes-BrakeLine)<=(0.5/(CarCount/16 + 1))){
        BrakeLine = EqualRes
    }
    
    #----------------
    #Locomotive Brake
    #----------------
    if(LocoAirBrakeType){
        #26L Independent
        LB16M_Notch = IncreaseLocoBrake - DecreaseLocoBrake
        if(IncreaseLocoBrake & (LocoBrakePressure==90) & !LB26L_ClickQ){
            LB26L_ClickQ = 1
            W:soundPlay(1,1,Lever_LocoBrake)
        }elseif(LocoBrakePressure<90){
            LB26L_ClickQ = 0
        }
    }else{
        #24RL Independent
        if(IncreaseLocoBrake & (LB16M_Notch<1) & !LBQ){
            LBQ = 1
            LB16M_Notch++
            if(LB16M_Notch==1){W:soundPlay(1,1,Lever_LocoBrake)}
        }elseif(DecreaseLocoBrake & (LB16M_Notch>-1) & !LBQ){
            LBQ = 1
            LB16M_Notch--
        }elseif(!DecreaseLocoBrake & !IncreaseLocoBrake & LBQ){
            LBQ = 0
}}
    
    #LB Hiss
    if((LB16M_Notch==-1) & (LocoBrakePressure>0) & !IHQ){
        IHQ = 1
        W:soundPlay(5,4,LocoBrakeRelease)
        timer("IHQ",6000)
    }
    
    #LB Indexing
    if((LB16M_Notch==1) & (LocoBrakePressure<65)){
        LocoBrakePressure += 1.4
    }elseif((LB16M_Notch==-1) & (LocoBrakePressure>0)){
        LocoBrakePressure -= 0.8
        
        if(LocoBrakePressure>(65-BrakeLine)){MainRes -= 0.125/NumCompressors}
    }
    
    #LB Bailoff Indexing
    if(BailOff & LocoBrakePressure>0){
        LocoBrakePressure -= 1.7
    }

    
    BrakeCyl = LocoBrakePressure

    #Brake Info Array
    BrakeInfo = array(MainRes,EqualRes,BrakeLine,LocoBrakePressure,BrakeCyl,EqualRes2)
    
    #Emergency Brake
    if((EmergencyBrake | EmBrake) & !Emergency){
        Emergency = 1
        BrakeLine = 0
        EqualRes = 0
        EqualRes2 = 0 
        AB24RL_Notch = 4
        
        local Ents = E:getConstraints()
        foreach(K,V:entity=Ents){
            V:propPhysicalMaterial("slipperyslime")
        }
        
        W:soundPlay(5,0,EmergencyBrakeSound)
        soundPitch(5,85)
        W:soundPlay(1,1,AirBrakeType ? Lever_26L : Lever_24RL)
        
        
        Notch = 0
        TQ = tq_evaluate(RealNotch,Notch)
        RealNotch = startTransition(RealNotch,Notch)
        
    }
    
    Brake = (BrakeCyl > 0)
    
    #Brake Screeching Sounds
    if(changed(EmergencyBrake==1)&EmergencyBrake==1){
    BrakeScreech = EmergencyBrakeWheels
    }
    elseif(changed(EmergencyBrake==1)&EmergencyBrake==0){
    BrakeScreech = BrakeScreech
    }
    
    local Screech = Moving & Brake & (MPH<25)
    if(Screech & !BQ){
            BQ = 1
        W:soundPlay(4,0,BrakeScreech)
        soundPitch(4,90)
    }elseif(!Screech & BQ){
        BQ = 0
        soundStop(4,0.4)
        soundPitch(4,120,0.5)
    }
    
    #Train Brake Physprops
    if(Brake & !BrakeCutout & (MPH<Threshold_Hard) & !BPQ){
        BPQ = 1
        Trucks:abRest()
        Locked = 1
        
    }elseif(!Brake & !BrakeCutout & BPQ){
        BPQ = 0
        E:abRelease()
        Locked = 0
        Emergency = 0
        CarCount = E:extraProps(CarCount_Init)
    }
    
    #Handbrake
    if(HandBrake | Handbrake & !HBQ){
        HBQ = 1
        print("[RLC Titus] Hold key to Apply Handbrakes.")
        timer("HB_Check",1000)
    }elseif(!HandBrake | !Handbrake & HBQ){
        HBQ = 0
    }
    
    #Train Brake Force Calculation
    if((MPH>Threshold_Hard)&!Locked&!BrakeCutout){
        if(CarCount<1){
            CarCount = E:extraProps(CarCount_Init)
        }
        local TBF = CarCount*(90-BrakeLine)*MaxTrainBrakeForce
        local LBF = ((90-BrakeLine)>LocoBrakePressure ? (90-BrakeLine) : LocoBrakePressure)*MaxLocoBrakeForce
        BrakingForce = sign(V)*(LBF+TBF)
        
    }else{
        BrakingForce = 0
        #LocoBrakingForce = 0
    }
    

    
    
    #------------------
    #WheelSlip & Sander
    #------------------
       if(Sander & !SandQ){
            SandQ = 1
            W:soundPlay(6,0,SanderOn)
            Trig = 1
        }elseif(!Sander & SandQ){
            SandQ = 0
            soundStop(6,2)
            Trig = 1
        }
    
    if(ETC!=2 & (Reverser!=0) & !Brake & !Dynamics){
        
        #Sander
#[        if(Sander & !SandQ){
            SandQ = 1
            W:soundPlay(6,0,SanderOn)
            Trig = 1
        }elseif(!Sander & SandQ){
            SandQ = 0
            W:soundPlay(6,2,SanderOff)
            Trig = 1
        }]#
        
        #Wheelslip
        local Throttle = min(RealNotch,Notch)
        if((Throttle>4) & (MPH<10) & !WSQ){
            local SpeedThreshold = (Throttle - 4 - 2*Sanding)*2.5
            
            WheelSlippable = MPH<SpeedThreshold
        }else{
            WheelSlippable = 0
        }
        if(WheelSlippable & !WheelSlip){
            if(random()<(Sanding ? WheelSlipProb/2 : WheelSlipProb)){
                WheelSlip = 1
                local Snd = WSC ? WheelSlipSound1 : WheelSlipSound2
                soundPlay(7,5,Snd)
                WSC = !WSC
                timer("WheelSlipEnd",sdr(Snd))
            }
        }elseif(!WheelSlippable & WheelSlip){
            WheelSlip = 0
            
            stoptimer("WheelSlipEnd")
            soundStop(7,1)
            timer("WheelSlipStart",1000)
        }
        if(WheelSlip){
            local TEMUL = ETC ? 0.5 : 0.25
            TE *= TEMUL
        }
        
        
    }else{
        WheelSlip = 0
        
    }
    
    #================================
    #Force Application & Load Systems
    #================================
    
    Force = TE - BrakingForce - DynaForce 
    W:applyForce(-E:up()*(Force))
    
    Current = (floor(1000*(abs(TE) - abs(DynaForce))/(TE_Starting*16)))
    Load=Current
    #Voltage = (floor(600*(abs(TE) - abs(DynaForce))/(TE_Starting*16)))

    
    #==============
    #MU Info Output
    #==============
    
    local HP_Forward = Horsepower + RearPlugIn[7,number]
    local HP_Backward = Horsepower + FrontPlugIn[7,number]
    local Comps_Forward = 1 + RearPlugIn[8,number]
    local Comps_Backward  = 1 + FrontPlugIn[8,number] 
    
    if(MU_Master){
        local ThrottleMU = (Dynamics ? DynaNotch : Notch)*1.25
        RearPlugOut = array(-Reverser,ThrottleMU,0,Dynamics,Trig,Sanding,HP_Backward,Comps_Backward,MainRes)
        FrontPlugOut = array(Reverser,ThrottleMU,0,Dynamics,Trig,Sanding,HP_Forward,Comps_Forward,MainRes)
    }else{
        RearPlugOut = FrontPlugIn:clone()
        FrontPlugOut = RearPlugIn:clone()
        
        RearPlugOut[7,number] = HP_Backward
        FrontPlugOut[7,number] = HP_Forward
        
        RearPlugOut[8,number] = Comps_Backward
        FrontPlugOut[8,number] = Comps_Forward
        
    }
    
}

if(changed(HandBrakeType == 1)&HandBrakeType == 1){
Lever_HandBrake = "titus's_trainbuild_content_pack_1.1/propper/misc/handbrake_apply.wav"
}
elseif(changed(HandBrakeType == 0)&HandBrakeType == 0){
Lever_HandBrake = "titus's_trainbuild_content_pack_1.1/propper/misc/handbrake02.wav"
}


#Handbrake Check
if(clk("HB_Check")){
    if(HandBrake | Handbrake == 1){
        local Ents = E:getConstraints()
        foreach(K,V:entity = Ents){
            V:propPhysicalMaterial("rubber")
        }
        print("[RLC Titus] Handbrakes Applied.")
        W:soundPlay(1,0,Lever_HandBrake)
    }
}


#Lever Unlock Indicator
Unlocked = On&(RealNotch==0)

#=============
#Chat Commands
#=============

if(chatClk(O)|chatClk(Driver)){
    Speaker = lastSpoke()
    LS = lastSaid()
    
    local Sentence = LS:explode(" ")
    local CMD = Sentence[1,string]
    
    switch(CMD){
        case ".engine",
            if(Speaker==O){
                SQ = 1
                
                Starting = (Sentence[2,string]=="") ? !Starting : Sentence[2,string]:toNumber()
                if(Starting){
                    local Snd = FuelSaver ? (LowIdling ? Startup:sub(1,Startup:length()-4) + "_low.wav" : Startup) : Startup
                    W:soundPlay(0,0,Snd)
                    timer("run",10*floor(soundDuration(Snd)*50) - 500)
                    timer("startclag",StartupClagStart*1000)
                    Speaker:printProper("[RLC Titus] Starting Engine.")
                    
                    if(DPM){
                        #print("Run")
                        DPMS = Snd
                        timer("dpm",sdr(Snd))
                    }
                }else{
                    On = 0
                    local Snd = FuelSaver ? (LowIdling ? Shutdown:sub(1,Shutdown:length()-4) + "_low.wav" : Shutdown) : Shutdown
                    W:soundPlay(0,0,Snd)
                    stopAllTimers()
                    timer("cool",10*floor(soundDuration(Snd)*50))
                    Speaker:printProper("[RLC Titus] Shutting Engine Down.")
                    
                    if(DPM){
                        DPMS = Snd
                        timer("dpm",sdr(Snd))
                    }
                }
            }
            hideChat(1)
            break
        case ".notch",
            if(MU_Master & On){
                Notch = clamp(Sentence[2,string]:toNumber(),0,8)
                TQ = tq_evaluate(RealNotch,Notch)
                RealNotch = startTransition(RealNotch,Notch)
                TQ = tq_evaluate(RealNotch,Notch)
                RealNotch = startTransition(RealNotch,Notch)
                Speaker:printProper("[RLC Titus] Setting Notch to " + Notch:toString() + ".")
                Trig2 = 1
            }elseif(On & !MU_Master){
                stoptimer("mu_recheck")
                timer("mu_recheck",1000)
            }
            hideChat(1)
            break
        case ".brake",
            if(MU_Master & On){
                if(Sentence[2,string]==""){
                    Emergency = 1
                    EqualRes = BrakeLine = 0
                    
                    local Ents = E:getConstraints()
                    foreach(K,V:entity=Ents){
                        V:propPhysicalMaterial("slipperyslime")
                    }
                    AB24RL_Notch = 2
                    Pod:soundPlay(5,0,EmergencyBrakeSound)
                    Pod:soundPlay(1,1,AirBrakeType ? Lever_26L : Lever_16M)
                    
                    
                    Notch = 0
                    TQ = tq_evaluate(RealNotch,Notch)
                    RealNotch = startTransition(RealNotch,Notch)
                    Speaker:printProper("[RLC Titus] Applying Emergency Brake.")
                }else{
                    local ToPressure = clamp(Sentence[2,string]:toNumber(),0,90)
                    if(!AirBrakeType){
                    AB24RL_Notch = 0
                    }
                    EqualRes = 90-ToPressure
                hideChat(1)
                #Trig2 = 1
            }
        }
            break
        case ".rev",
            if(MU_Master & On){
                Reverser = clamp(Sentence[2,string]:toNumber(),-1,1)
                Speaker:printProper("[RLC Titus] Setting Reverser to " + Reverser:toString() + ".")
                Trig2 = 1
            }
            hideChat(1)
            break
        case ".dynamics",
            if(On & MU_Master){
                if(DynamicsEnable){
                    local CanEngage = (DynaNotch==0) ? (RealNotch==0) : 1
                    if((Reverser!=0) & CanEngage){
                        
                        DynaNotch = Sentence[2,string]:toNumber()
                        Dynamics = DynaNotch > 0
                        Speaker:printProper("[RLC Titus] Setting Dynamic Brakes to Notch " + Sentence[2,string] + ".")
                    }else{
                        Speaker:printProper("[RLC Titus] Dynamic Brake Condition Invalid!")
                    }
                }else{
                    Speaker:printProper("[RLC Titus] Locomotive has no Dynamic Brakes!")
                }
            }elseif(On & !MU_Master){
                stoptimer("mu_recheck")
                timer("mu_recheck",1000)
            }
            hideChat(1)
            break
        case ".handbrake",
            if(MU_Master){
                local Ents = E:getConstraints()
                foreach(K,V:entity = Ents){
                    V:propPhysicalMaterial("rubber")
                }
                Speaker:printProper("[RLC Titus] Handbrakes Applied.")
                Pod:soundPlay(1,1,Lever_HandBrake)
            }
            hideChat(1)
            break
        case ".controls",
            if(MU_Master){
                for(K=1,ControlPrintOrder:count()){
                    local ControlName = ControlPrintOrder[K,string]
                    local X = Controls[ControlName,string]
                    if(Routing[ControlName,number]){
                        Speaker:printProper(ControlName + ": Shift + " + X)
                    }else{
                        Speaker:printProper(ControlName + ": " + X)
                    }
                }
            }
            hideChat(1)
            break
        case ".superice",
            if(MU_Master){
                E:abRelease()
                Speaker:printProper("[RLC Titus] Consist has been Super Iced.")
            }
            hideChat(1)
            break
        case ".count",
            if(MU_Master){Speaker:printProper("[RLC Titus] Your Train has " + CarCount:toString() + " cars.")}
            hideChat(1)
            break
        case ".weight",
            if(MU_Master){
                local TMass = 0
                local TProps = E:getConstraints()
                for(N=1,TProps:count()){
                    TMass += TProps[N,entity]:mass()
                }
                TMass -= 80000
                local SCE = round(TMass/25000,1)
                Speaker:printProper("[RLC Titus] Total Car Mass: " + SCE:toString() + " SCE.")
            }
            hideChat(1)
            break
        case ".switching",
            if(MU_Master){
                Switching = Sentence[2,string]:toNumber()
                if(Switching){
                    Speaker:printProper("[RLC Titus] Switching Mode Engaged.")
                }else{
                    Speaker:printProper("[RLC Titus] Switching Mode Disengaged.")
                }
                hideChat(1)
            }
            break
        default,
            break
    }
}
#===============================================================================

if(changed(Clag == 1)&Clag == 1){
    ConstantClag = 1
}
elseif(changed(Stop == 1)&Stop == 1){
    ConstantClag = 0
}

if(EngineMute){
soundVolume(0,0)
}
else{
soundVolume(0,1)
}  
